//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//              Базовое программное обеспечение нейропроцессора             //
//                                                                          //
//              Библиотека времени выполнения                               //
//                                                                          //
//                          Модуль RTMACRO                                  //
//                                                                          //
//   Макросы для генератора ассемблерного кода, обеспечивающие              //
//   работу со встроенными типами данных                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

// АВТОРЫ: Забалуев, Челюбеев А.А.
// ВЕРСИЯ: 02 ( 27.11.97 )
// СТАТУС: тестирование
// КОММЕНТАРИЙ: файл транслируется в библиотеку макросов, которая импортируется
// во всех ассемблерных файлах, порожденных кодогенератором.
// Версия 2: изменено соглашение о вызове встроенных функций. Все детали вызова
// собраны в макросы CALL_BUILTIN_xxx. Обеспечено выравнивание стека.

// ЗАМЕЧАНИЕ: Регистр gr7 НЕЛЬЗЯ использовать в качестве параметра данных
// макросов.

    //-------------------------------------------------
    // Макросы конвенции о вызовах из библиотеки libasm
    //-------------------------------------------------

// Функции из библиотеки libasm имеют свою собственную конвенцию
// о вызовах. Данная конвенция различается для функций с различным 
// числом параметров.
// Макросы CALL_BUILTIN_xxxx задают конвенцию о вызове для функции
// в зависимости от числа аргументов.
// Каждый регистр рассматривается как отдельный аргумент.
// CALL_BUILTIN_2x1 - функция принимает два аргумента, возвращает один 
// CALL_BUILTIN_4x2 - функция принимает четыре аргумента, возвращает два
// CALL_BUILTIN_2x2 - функция принимает два аргумента, возвращает два 
// CALL_BUILTIN_1x2 - функция принимает один аргумент, возвращает два 

//==============================================================
// Макрос вызывает функцию с двумя параметрами
// возвращаемое значение помещается в один регистр
// 
// CALL_BUILTIN_2x1( 
//          Func,   - Имя вызываемой функции
//          Arg1,   - регистр первого аргумента
//          Arg2,   - регистр второго аргумента
//          Res     - регистр результата
//     )
//
//==============================================================
macro CALL_BUILTIN_2x1( Func, Arg1, Arg2, Res )

        // перспективный вариант соглашения о вызовах для 2 аргументов
        // параметры функции находятся выше сохраненного PC,PSW
    delayed call Func;
    push Arg1;
    push Arg2;
        // end of delayed commands of call

    Res = gr7;

end CALL_BUILTIN_2x1;

//==============================================================
// Макрос вызывает функцию с четыремя параметрами
// возвращаемое значение помещается в два регистра
// 
// CALL_BUILTIN_4x2( 
//          Func,   - Имя вызываемой функции
//          Arg1,   - регистр первого аргумента
//          Arg2,   - регистр второго аргумента
//          Arg3,   - регистр третьего аргумента
//          Arg4,   - регистр четвертого аргумента
//          Res1,   - первый регистр результата
//          Res2    - второй регистр результата
//     )
//
//==============================================================
macro CALL_BUILTIN_4x2( Func, Arg1, Arg2, Arg3, Arg4, Res1, Res2 )

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = Arg1;
    [ ar5++ ] = Arg2;
    [ ar5++ ] = Arg3;
    [ ar5 ] = Arg4;

    call Func;

    ar5 = sp;
    Res1 = [ --ar5 ];
    Res2 = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;

end CALL_BUILTIN_4x2;

//==============================================================
// Макрос вызывает функцию с двумя параметрами
// возвращаемое значение помещается в два регистра
// 
// CALL_BUILTIN_2x2( 
//          Func,   - Имя вызываемой функции
//          Arg1,   - регистр первого аргумента
//          Arg2,   - регистр второго аргумента
//          Res1,   - первый регистр результата
//          Res2    - второй регистр результата
//     )
//
//==============================================================
macro CALL_BUILTIN_2x2( Func, Arg1, Arg2, Res1, Res2 )

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;

    call Func;

    ar5 = sp;
    Res1 = [ --ar5 ];
    Res2 = [ --ar5 ];
    sp -= 2;

end CALL_BUILTIN_2x2;

//==============================================================
// Макрос вызывает функцию с одним параметром
// возвращаемое значение помещается в два регистра
// 
// CALL_BUILTIN_1x2( 
//          Func,   - Имя вызываемой функции
//          Arg1,   - регистр первого аргумента
//          Res1,   - первый регистр результата
//          Res2    - второй регистр результата
//     )
//
//==============================================================
macro CALL_BUILTIN_1x2( Func, Arg, Res1, Res2 )

        // перспективный вариант вызова:
        // параметр передается в gr7
        // возвращаются значения на вершине стека.
    delayed call Func with gr7 = Arg;
    nul 32;
    // call Func;

    if false delayed skip 2;
    Res1 = [ --ar7 ];
    Res2 = [ --ar7 ];
    // if never delayed skip 2;

end CALL_BUILTIN_1x2;


    //-------------------------------------------------
    // Макросы для неподдерживаемых операций с 
    // короткими числами - 32 бита.
    // Макросы для работы с длинными числами 64 бита
    //-------------------------------------------------



//======== Макрос MULT32 =========
// Умножение 32-битных чисел, знаковое или беззнаковое,
// с 32-битным результатом. (Новый вариант с вызовом функции).
// На входе:    Arg1 - регистр с первым множителем
//              Arg2 - регистр со вторым множителем
// На выходе:   Res - младшие 32 бита результата
// Изменяет:    gr7
// ЗАМЕЧАНИЕ: Arg1 и Arg2 могут совпадать.
macro MULT32 ( Res, Arg1, Arg2 )

    extern Mul32 : label;
    
    CALL_BUILTIN_2x1( Mul32, Arg1, Arg2, Res );
    
end MULT32;
    
//======== Макрос MULT32Speed =========
// Умножение 32-битных чисел, знаковое или беззнаковое,
// с 32-битным результатом.
// Старый вариант быстрее нового на 30%, зато в 3 раза больше по коду.
// На входе:    Arg1 - регистр с первым множителем
//              Arg2 - регистр со вторым множителем
// На выходе:   Res - младшие 32 бита результата
// Изменяет:    gr7
// ЗАМЕЧАНИЕ: Arg1 и Arg2 не могут совпадать.

macro MULT32Speed ( Res, Arg1, Arg2 )

    with gr7 = Arg2;
    with Arg2 = Arg1 *: gr7;
.repeat 15;
    with Arg2 = Arg1 * gr7;
.endrepeat;
    with Res = gr7;

end MULT32Speed;


//======= Макрос IDIV32 =========
// Деление 32-разрядных чисел со знаком
// На входе:    Arg1 - регистр с делимым,
//              Arg2 - регистр с делителем,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с частным.
// Изменяет:    gr7,ar5.
macro IDIV32 ( Res, Arg1, Arg2 )
extern IDiv32 :label;

    CALL_BUILTIN_2x1( IDiv32, Arg1, Arg2, Res );

end IDIV32;


//======= Макрос UDIV32 =========
// Деление 32-разрядных чисел без знака.
// На входе:    Arg1 - регистр с делимым,
//              Arg2 - регистр с делителем,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с частным.
// Изменяет:    gr7,ar5.
macro UDIV32 ( Res, Arg1, Arg2 )
extern UDiv32 :label;

    CALL_BUILTIN_2x1( UDiv32, Arg1, Arg2, Res );

end UDIV32;


//======= Макрос IMOD32 =========
// Вычисление остатка от деления 32-разрядных чисел со знаком
// На входе:    Arg1 - регистр с делимым,
//              Arg2 - регистр с делителем,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с остатком.
// Изменяет:    gr7,ar5.
macro IMOD32 ( Res, Arg1, Arg2 )
extern IMod32 :label;

    CALL_BUILTIN_2x1( IMod32, Arg1, Arg2, Res );

end IMOD32;


//======= Макрос UMOD32 =========
// Вычисление остатка от деления 32-разрядных чисел со знаком
// На входе:    Arg1 - регистр с делимым,
//              Arg2 - регистр с делителем,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с остатком.
// Изменяет:    gr7,ar5.
macro UMOD32 ( Res, Arg1, Arg2 )
extern UMod32 :label;

    CALL_BUILTIN_2x1( UMod32, Arg1, Arg2, Res );

end UMOD32;


//======= Макрос LSHIFT32 ========
// Логический сдвиг влево 32-битного числа.
// Величина сдвига находится в регистре.
// На входе:    Arg - регистр со сдвигаемым значением,
//              Val - регистр с величиной сдвига,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7,ar5.
macro LSHIFT32 ( Res, Arg, Val )
extern LShift32 :label;

    CALL_BUILTIN_2x1( LShift32, Arg, Val, Res );

end LSHIFT32;


//======= Макрос RSHIFT32 ========
// Логический сдвиг вправо 32-битного числа.
// Величина сдвига находится в регистре.
// На входе:    Arg - регистр со сдвигаемым значением,
//              Val - регистр с величиной сдвига,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7,ar5.
macro RSHIFT32 ( Res, Arg, Val )
extern RShift32 :label;

    CALL_BUILTIN_2x1( RShift32, Arg, Val, Res );

end RSHIFT32;


//======= Макрос ARSHIFT32 ========
// Арифметический сдвиг вправо 32-битного числа.
// Величина сдвига находится в регистре.
// На входе:    Arg - регистр со сдвигаемым значением,
//              Val - регистр с величиной сдвига,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7,ar5.
macro ARSHIFT32 ( Res, Arg, Val )
extern ARShift32 :label;

    CALL_BUILTIN_2x1( ARShift32, Arg, Val, Res );

end ARSHIFT32;


//======= Макрос UTRUNC8 ========
// Усечение 32-разрядного значения до 8 младших бит без распространения знака.
// На входе:    Src - регистр с операндом.
// На выходе:   Dst - регистр с результатом.
macro UTRUNC8 ( Dst, Src )
    Dst = Src << 24;
    Dst >>= 24;
end UTRUNC8;


//======= Макрос ITRUNC8 ========
// Усечение 32-разрядного значения до 8 младших бит c распространением знака
// 8-го бита.
// На входе:    Src - регистр с операндом.
// На выходе:   Dst - регистр с результатом.
macro ITRUNC8 ( Dst, Src )
    Dst = Src << 24;
    Dst A>>= 24;
end ITRUNC8;


//======= Макрос UTRUNC16 ========
// Усечение 32-разрядного значения до 16 младших бит без распространения знака.
// На входе:    Src - регистр с операндом.
// На выходе:   Dst - регистр с результатом.
macro UTRUNC16 ( Dst, Src )
    Dst = Src << 16;
    Dst >>= 16;
end UTRUNC16;


//======= Макрос ITRUNC16 ========
// Усечение 32-разрядного значения до 16 младших бит c распространением знака
// 16-го бита.
// На входе:    Src - регистр с операндом.
// На выходе:   Dst - регистр с результатом.
macro ITRUNC16 ( Dst, Src )
    Dst = Src << 16;
    Dst A>>= 16;
end ITRUNC16;


//======= Макрос LOAD64C ========
// Загрузка регистровой пары 64-битным значением.
// На входе:    Val - значение-константа.
// На выходе:   ResLo - регистр с младшими 32 битами,
//              ResHi - регистр со старшими 32 битами.
macro LOAD64C ( ResLo, ResHi, Val )
    ResLo = loword( Val );
    ResHi = hiword( Val );
end LOAD64C;


macro ADD64 ( ResLo, ResHi, A1Lo, A1Hi, A2Lo, A2Hi )
            gr7 = A1Lo + A2Lo;
            ResLo = gr7
                with ResHi = A1Hi + A2Hi + carry;
end ADD64;


macro SUB64 ( ResLo, ResHi, A1Lo, A1Hi, A2Lo, A2Hi )
            gr7 = A1Lo - A2Lo;
            ResLo = gr7
                with ResHi = A1Hi - A2Hi - 1 + carry;
end SUB64;


//======= Макрос NEG64 ========
// Обращение знака 64-разрядного числа.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет: gr7, ArgLo.
macro NEG64 ( ResLo, ResHi, ArgLo, ArgHi )
    ResHi = false;
    ArgLo = -ArgLo;
    ResLo = ArgLo
        with ResHi = ResHi - ArgHi - 1 + carry;
end NEG64;


//======= Макрос MULT64 =========
// Умножение 64-битных чисел, знаковых либо беззнаковых.
// На входе:    LeftLo - младшие 32 бита 1-го операнда,
//              LeftHi - старшие 32 бита 1-го операнда,
//              RightLo - младшие 32 бита 2-го операнда,
//              RightHi - старшие 32 бита 2-го операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro MULT64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )

    extern Mul64 :label;

    CALL_BUILTIN_4x2(Mul64, LeftLo, LeftHi, RightLo, RightHi, ResHi, ResLo );
    
end MULT64;

//======= Макрос MULT64Vect =========
// Умножение 64-битных чисел, знаковых либо беззнаковых.
// Старый вариант использующий векторный процессор.
// На входе:    LeftLo - младшие 32 бита 1-го операнда,
//              LeftHi - старшие 32 бита 1-го операнда,
//              RightLo - младшие 32 бита 2-го операнда,
//              RightHi - старшие 32 бита 2-го операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro MULT64Vect ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )

    nb1 = 0;        // длинный нуль
    sb = 0;
    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5++ ] = RightHi;
    rep 1 wfifo = [ --ar5 ], ftw, wtw;
    rep 1 data = [ --ar5 ] with vsum , data, 0;
    rep 1 [ar5] = afifo;
    ResLo = [ ar5++ ];
    ResHi = [ ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).
    sp -= 4;
    
end MULT64Vect;


//======= Макрос IDIV64 ========
// Деление 64-разрядных чисел со знаком.
// На входе:    LeftLo - младшие 32 бита 1-го операнда,
//              LeftHi - старшие 32 бита 1-го операнда,
//              RightLo - младшие 32 бита 2-го операнда,
//              RightHi - старшие 32 бита 2-го операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro IDIV64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )
extern IDiv64 :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5 ]   = RightHi;
    call IDiv64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).
    sp -= 4;
end IDIV64;


//======= Макрос UDIV64 ========
// Деление 64-разрядных чисел без знака.
// На входе:    LeftLo - младшие 32 бита 1-го операнда,
//              LeftHi - старшие 32 бита 1-го операнда,
//              RightLo - младшие 32 бита 2-го операнда,
//              RightHi - старшие 32 бита 2-го операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro UDIV64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )
extern UDiv64 :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5 ]   = RightHi;
    call UDiv64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end UDIV64;


//======= Макрос IMOD64 ========
// Вычисление остатка от деления 64-разрядных чисел со знаком.
// На входе:    LeftLo - младшие 32 бита 1-го операнда,
//              LeftHi - старшие 32 бита 1-го операнда,
//              RightLo - младшие 32 бита 2-го операнда,
//              RightHi - старшие 32 бита 2-го операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro IMOD64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )
extern IMod64 :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5 ]   = RightHi;
    call IMod64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end IMOD64;


//======= Макрос UMOD64 ========
// Вычисление остатка от деления 64-разрядных чисел без знака.
// На входе:    LeftLo - младшие 32 бита 1-го операнда,
//              LeftHi - старшие 32 бита 1-го операнда,
//              RightLo - младшие 32 бита 2-го операнда,
//              RightHi - старшие 32 бита 2-го операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro UMOD64 ( ResLo, ResHi, LeftLo, LeftHi, RightLo, RightHi )
extern UMod64 :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LeftLo;
    [ ar5++ ] = LeftHi;
    [ ar5++ ] = RightLo;
    [ ar5 ]   = RightHi;
    call UMod64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end UMOD64;


//======= Макрос LSHIFT64 ========
// Логический сдвиг влево 64-разрядного числа.
// Величина сдвига находится в регистре.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              Sh - величина сдвига,
//              стек выровнен по четному адресу.
// Изменяет: gr7,ar5.
macro LSHIFT64 ( ResLo, ResHi, ArgLo, ArgHi, Sh )
extern LShift64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo
        with gr7 = Sh;
    [ ar5++ ] = ArgHi;
    call LShift64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end LSHIFT64;


//======= Макрос RSHIFT64 ========
// Логический сдвиг вправо 64-разрядного числа.
// Величина сдвига находится в регистре.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              Sh - величина сдвига,
//              стек выровнен по четному адресу.
// Изменяет: gr7,ar5.
macro RSHIFT64 ( ResLo, ResHi, ArgLo, ArgHi, Sh )
extern RShift64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo
        with gr7 = Sh;
    [ ar5++ ] = ArgHi;
    call RShift64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end RSHIFT64;


//======= Макрос ARSHIFT64 ========
// Арифметический сдвиг вправо 64-разрядного числа.
// Величина сдвига находится в регистре.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              Sh - величина сдвига,
//              стек выровнен по четному адресу.
// Изменяет: gr7,ar5.
macro ARSHIFT64 ( ResLo, ResHi, ArgLo, ArgHi, Sh )
extern ARShift64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo
        with gr7 = Sh;
    [ ar5++ ] = ArgHi;
    call ARShift64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end ARSHIFT64;


//======= Макрос I32TO64 =========
// Преобразование 32-битного целого со знаком в 64-битное.
// На входе:    Val - регистр с операндом
// На выходе:   ResLo - регистр с младшими 32 битами результата
//              ResHi - регистр со старшими 32 битами результата
macro I32TO64 ( ResLo, ResHi, Val )
    ResLo = Val
        with ResHi = Val A>> 31;
end I32TO64;


//======= Макрос U32TO64 =========
// Преобразование 32-битного целого без знака в 64-битное.
// На входе:    Val - регистр с операндом
// На выходе:   ResLo - регистр с младшими 32 битами результата
//              ResHi - регистр со старшими 32 битами результата
macro U32TO64 ( ResLo, ResHi, Val )
    ResLo = Val
        with ResHi = false;
end U32TO64;


//======= Макрос STASG ========
// Порождает код, копирующий (небольшой) массив данных (структуру).
// На входе:    Dst - адресный регистр с адресом реципиента (не ar5),
//              Src - адресный регистр с адресом источника (не ar5),
//              Size - длина копируемой области.
// Изменяет: Dst, Src, gr6, gr7.
macro STASG ( Dst, Src, Size )

extern _memcpy : label;

    // Когда размер структуры небольшой копируем напрямую.
    // Размер получающегося кода 2 + 2*Size
.if Size < 10;
    Src += Size;
    Dst += Size;
.repeat Size;
    gr7 = [ --Src ];
    [ --Dst ] = gr7;
.endrepeat;
.endif;

	// Если же размер структуры большой, то используем memcpy
    // Размер кода 20 слов. Критический размер Size = (20-2)/2 = 9.
.if Size >= 10;
    gr7 = Size;
    
    if false delayed skip 0;
    push ar5;
    push gr7;
    
    if false delayed skip 0;
    push Src;
    push Dst;
    
    call _memcpy;
    
    ar7 -= 2;
    
    if false delayed skip 0;
    pop gr7;
    pop ar5;
    
.endif;

end STASG;


//===== Макрос UGFLD =======
// Доступ к  беззнаковому битовому полю структуры
// На входе:    Addr    - регистр с адресом 32-битного слова
//              Offset  - смещение от начала слова в битах
//              Size    - размер поля в битах
// На выходе:   Res     - регистр с результатом
// Замечание: данные в структуре расположены от младших бит к старшим.
macro UGFLD ( Res, Addr, Offset, Size )
    Res = [ Addr ];
    Res <<= 32 - Offset - Size;
    Res >>= 32 - Size;
end UGFLD;


//===== Макрос IGFLD =======
// Доступ к  знаковому битовому полю структуры
// На входе:    Addr    - регистр с адресом 32-битного слова
//              Offset  - смещение от начала слова в битах
//              Size    - размер поля в битах
// На выходе:   Res     - регистр с результатом
// Замечание: данные в структуре расположены от младших бит к старшим.
macro IGFLD ( Res, Addr, Offset, Size )
    Res = [ Addr ];
    Res <<= 32 - Offset - Size;
    Res A>>= 32 - Size;
end IGFLD;


//===== Макрос ESFLD =======
// Расширение знака для значения битового поля структуры.
// На входе:    Input   - регистр с значением поля
//              Offset  - смещение от начала слова в битах
//              Size    - размер поля в битах
// На выходе:   Res     - регистр с результатом
// Замечание: данные в структуре расположены от младших бит к старшим.
macro ESFLD ( Res, Offset, Size, Input )
    Res = Input << 32 - Size;
    Res A>>= 32 - Size;
end ESFLD;


//===== Макрос SFLD0 =======
// Присваивание битовому полю структуры.
// На входе:    Addr    - регистр с адресом 32-битного слова
//              Offset  - смещение от начала слова в битах
//              Size    - размер поля в битах
//              Val     - присваиваемое полю значение
//                          (регистр кроме gr0 либо константа)
// Замечание: данные в структуре расположены от младших бит к старшим.
macro SFLD0 ( Addr, Offset, Size, Val )
    push ar0, gr0;
    gr0 = [ Addr ];
    gr7 = ( 0ffffffffh << ( Offset + Size ) ) or
          ( 0ffffffffh >> ( 32 - Offset ) );   // маска
    gr0 = gr0 and gr7;  // обнуляем поле

        // some work to avoid shift on zero bits.
.if ( 32 - Size ) == 0;
    gr7 = Val;
.endif;
.if ( 32 - Size ) != 0;
    gr7 = Val << ( 32 - Size );
.endif;

    gr7 >>= ( 32 - Offset - Size );
    gr7 = gr0 or gr7;   // устанавливаем поле
    pop ar0, gr0;
    [ Addr ] = gr7;
end SFLD0;


//===== Макрос SFLD1 =======
// Присваивание битовому полю структуры.
// На входе:    Addr    - регистр с адресом 32-битного слова
//              Offset  - смещение от начала слова в битах
//              Size    - размер поля в битах
//              Val     - присваиваемое полю значение
//                          (регистр кроме gr1 либо константа).
// Замечание: данные в структуре расположены от младших бит к старшим.
macro SFLD1 ( Addr, Offset, Size, Val )
    push ar1, gr1;
    gr1 = [ Addr ];
    gr7 = ( 0ffffffffh << ( Offset + Size ) ) or
          ( 0ffffffffh >> ( 32 - Offset ) );   // маска
    gr1 = gr1 and gr7;  // обнуляем поле

        // some work to avoid shift on zero bits.
.if ( 32 - Size ) == 0;
    gr7 = Val;
.endif;
.if ( 32 - Size ) != 0;
    gr7 = Val << ( 32 - Size );
.endif;

    gr7 >>= ( 32 - Offset - Size );
    gr7 = gr1 or gr7;   // устанавливаем поле
    pop ar1, gr1;
    [ Addr ] = gr7;
end SFLD1;


//======= Макрос FEQ =======
// Res = ( Arg1 == Arg2 )
// На входе: Arg1, Arg2 - регистры со значениями типа float,
//           стек должен быть выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет: ar5, gr7.
macro FEQ ( Res, Arg1, Arg2 )
extern FCmp :label;
own Cont :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;
    call FCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 2;
    // cond. skip Cont
    if <>0 skip Cont;
    Res++;
<Cont>
end FEQ;


//======= Макрос FNE =======
// Res = ( Arg1 != Arg2 )
// На входе: Arg1, Arg2 - регистры со значениями типа float,
//           стек должен быть выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет: ar5, gr7.
macro FNE ( Res, Arg1, Arg2 )
extern FCmp :label;
own True :label;
own Cont :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;
    call FCmp;
    if carry delayed skip True
        with Res = false noflags;
    sp -= 2;
    // cond. skip Cont
    if =0 skip Cont;
<True>
    Res++;
<Cont>
end FNE;


//======= Макрос FLT =======
// Res = ( Arg1 < Arg2 )
// На входе: Arg1, Arg2 - регистры со значениями типа float,
//           стек должен быть выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет: gr7, ar5.
macro FLT ( Res, Arg1, Arg2 )
extern FCmp :label;
own Cont :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;
    call FCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 2;
    // cond. skip Cont
    if >= skip Cont;
    Res++;
<Cont>
end FLT;


//======= Макрос FGT =======
// Res = ( Arg1 > Arg2 )
// На входе: Arg1, Arg2 - регистры со значениями типа float,
//           стек должен быть выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет: gr7, ar5
macro FGT ( Res, Arg1, Arg2 )
    FLT( Res, Arg2, Arg1 );
end FGT;


//======= Макрос FGE =======
// Res = ( Arg1 >= Arg2 )
// На входе: Arg1, Arg2 - регистры со значениями типа float,
//           стек должен быть выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет: gr7, ar5
macro FGE ( Res, Arg1, Arg2 )
extern FCmp :label;
own Cont :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = Arg1;
    [ ar5 ] = Arg2;
    call FCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 2;
    // cond. skip Cont
    if < skip Cont;
    Res++;
<Cont>
end FGE;


//======= Макрос FLE =======
// Res = ( Arg1 <= Arg2 )
// На входе: Arg1, Arg2 - регистры со значениями типа float,
//           стек должен быть выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет: gr7, ar5
macro FLE ( Res, Arg1, Arg2 )
    FGE( Res, Arg2, Arg1 );
end FLE;


//====== Макрос FNEG =======
// Res = - Arg
// На входе:    Arg - регистр со значением типа float.
// На выходе:   Res - регистр со значением типа bool.
macro FNEG ( Res, Arg )
    Res = 80000000h;
    Res = Res xor Arg;
end FNEG;


//====== Макрос FADD =======
// Сложение чисел типа float
// Res = Arg1 + Arg2
// Изменяет: gr7, ar5
// Стек должен быть выровнен по четному адресу
macro FADD ( Res, Arg1, Arg2 )
extern FAdd :label;

    CALL_BUILTIN_2x1( FAdd, Arg1, Arg2, Res );

end FADD;


//====== Макрос FSUB =======
// Вычитание чисел типа float
// Res = Arg1 - Arg2
// Изменяет: gr7, ar5
// Стек должен быть выровнен по четному адресу
// Arg2 не должен быть gr7
macro FSUB ( Res, Arg1, Arg2 )
extern FAdd :label;

        // меняем знак Arg2 и затем складываем.
    FNEG( gr7, Arg2 );
    CALL_BUILTIN_2x1( FAdd, Arg1, gr7, Res );

end FSUB;


//====== Макрос FMUL =======
// Умножение чисел типа float
// Res = Arg1 * Arg2
// Изменяет: gr7, ar5
// Стек должен быть выровнен по четному адресу
macro FMUL ( Res, Arg1, Arg2 )
extern FMul :label;

    CALL_BUILTIN_2x1( FMul, Arg1, Arg2, Res );

end FMUL;


//====== Макрос FDIV =======
// Деление чисел типа float
// Res = Arg1 / Arg2
// Изменяет: gr7, ar5
// Стек должен быть выровнен по четному адресу
macro FDIV ( Res, Arg1, Arg2 )
extern FDiv :label;

    CALL_BUILTIN_2x1( FDiv, Arg1, Arg2, Res );

end FDIV;


//====== Макрос I32TOF =======
// Конвертирует 32-разрядное целое число со знаком в число типа float.
// ЗАМЕЧАНИЕ: этим макросом можно конвертировать во float значения целых
// знаковых типов размера 1.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro I32TOF ( Res, Arg )
extern ConvI32toF :label;

    call ConvI32toF
        with gr7 = Arg;
    with Res = gr7;
end I32TOF;


//====== Макрос U32TOF =======
// Конвертирует 32-разрядное целое число без знака в число типа float.
// ЗАМЕЧАНИЕ: этим макросом можно конвертировать во float значения целых
// беззнаковых типов размера 1.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro U32TOF ( Res, Arg )
extern ConvU32toF :label;

    call ConvU32toF
        with gr7 = Arg;
    with Res = gr7;
end U32TOF;


//======= Макрос I64TOF =======
// Конвертирует 64-разрядное целое число со знаком в число типа float.
// На входе:    ArgLo - регистр с младшими 32 битами операнда,
//              ArgHi - регистр со старшими 32 битами операнда,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro I64TOF ( Res, ArgLo, ArgHi )
extern ConvI64toF :label;

    CALL_BUILTIN_2x1( ConvI64toF, ArgLo, ArgHi, Res );

end I64TOF;


//======= Макрос U64TOF =======
// Конвертирует 64-разрядное целое число без знака в число типа float.
// На входе:    ArgLo - регистр с младшими 32 битами операнда,
//              ArgHi - регистр со старшими 32 битами операнда,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro U64TOF ( Res, ArgLo, ArgHi )
extern ConvU64toF :label;

    CALL_BUILTIN_2x1( ConvU64toF, ArgLo, ArgHi, Res );

end U64TOF;


//====== Макрос FTOI32 =======
// Конвертирует число типа float в 32-разрядное целое со знаком,
// т.е. в любой целочисленный знаковый тип размера 1.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro FTOI32 ( Res, Arg )
extern ConvFtoI32 :label;

    call ConvFtoI32
        with gr7 = Arg;
    with Res = gr7;

end FTOI32;


//====== Макрос FTOU32 =======
// Конвертирует число типа float в 32-разрядное целое без знака,
// т.е. в любой целочисленный беззнаковый тип размера 1.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro FTOU32 ( Res, Arg )
extern ConvFtoU32 :label;

    call ConvFtoU32
        with gr7 = Arg;
    with Res = gr7;

end FTOU32;


//====== Макрос FTOI64 =======
// Конвертирует число типа float в 64-разрядное целое со знаком.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - регистр с младшими 32 битами результата,
//              ResHi - регистр со старшими 32 битами результата.
// Изменяет:    gr7, ar5
macro FTOI64 ( ResLo, ResHi, Arg )
extern ConvFtoI64 :label;

    CALL_BUILTIN_1x2( ConvFtoI64, Arg, ResHi, ResLo );

//    sp += 2;
//    call ConvFtoI64 with gr7 = Arg;
//    ar5 = sp;
//    ResHi = [ --ar5 ];
//    ResLo = [ --ar5 ];
//    sp -= 2;
end FTOI64;


//====== Макрос FTOU64 =======
// Конвертирует число типа float в 64-разрядное целое без знака.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по нечетному адресу.
// На выходе:   ResLo - регистр с младшими 32 битами результата,
//              ResHi - регистр со старшими 32 битами результата.
// Изменяет:    gr7, ar5
macro FTOU64 ( ResLo, ResHi, Arg )
extern ConvFtoU64 :label;

    CALL_BUILTIN_1x2( ConvFtoU64, Arg, ResHi, ResLo );
//    sp += 2;
//    ar5 = sp;
//    [ --ar5 ] = Arg;
//    call ConvFtoU64;
//    ar5 = sp;
//    ResHi = [ --ar5 ];
//    ResLo = [ --ar5 ];
//    sp -= 2;
end FTOU64;


//======= Макрос DEQ =======
// Проверка двух чисел типа double на равенство.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет:    ar5, gr7
macro DEQ ( Res, LLo, LHi, RLo, RHi )
extern  DCmp :label;
own     Cont :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 4;
    // cond. skip Cont
    if <>0 skip Cont;
    Res++;
<Cont>
end DEQ;


//======= Макрос DNE =======
// Проверка двух чисел типа double на неравенство.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
// На выходе: Res - регистр со значением типа bool
// Изменяет:    gr7
macro DNE ( Res, LLo, LHi, RLo, RHi )
extern  DCmp :label;
own     Cont :label;
own     True :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DCmp;
    if carry delayed skip True
        with Res = false noflags;
    sp -= 4;
    // cond. skip True
    if =0 skip Cont;
<True>
    Res++;
<Cont>
end DNE;


//======= Макрос DLT =======
// Проверка двух чисел типа double на <.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет:    gr7, ar5.
macro DLT ( Res, LLo, LHi, RLo, RHi )
extern  DCmp    :label;
own     Cont    :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 4;
    // cond. skip Cont
    if >= skip Cont;
    Res++;
<Cont>
end DLT;


//======= Макрос DGT =======
// Проверка двух чисел типа double на >.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет:    gr7, ar5.
macro DGT ( Res, LLo, LHi, RLo, RHi )
    DLT( Res, RLo, RHi, LLo, LHi );
end DGT;


//======= Макрос DGE =======
// Проверка двух чисел типа double на >=.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет:    gr7, ar5.
macro DGE ( Res, LLo, LHi, RLo, RHi )
extern  DCmp    :label;
own     Cont    :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DCmp;
    if carry delayed skip Cont
        with Res = false noflags;
    sp -= 4;
    // cond. skip Cont
    if < skip Cont;
    Res++;
<Cont>
end DGE;


//======= Макрос DLE =======
// Проверка двух чисел типа double на <=.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе: Res - регистр со значением типа bool
// Изменяет:    gr7, ar5.
macro DLE ( Res, LLo, LHi, RLo, RHi )
    DGE( Res, RLo, RHi, LLo, LHi );
end DLE;


//====== Макрос DNEG =======
// Обращение знака числа типа double.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro DNEG ( ResLo, ResHi, ArgLo, ArgHi )
    ResHi = 80000000h
        with ResLo = ArgLo noflags;
    ResHi = ResHi xor ArgHi noflags;
end DNEG;


//======= Макрос DADD =======
// Сложение двух чисел типа double.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro DADD ( ResLo, ResHi, LLo, LHi, RLo, RHi )
extern DAdd :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DAdd;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end DADD;


//======= Макрос DSUB =======
// Вычитание двух чисел типа double.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro DSUB ( ResLo, ResHi, LLo, LHi, RLo, RHi )
extern DAdd :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    gr7 = 80000000h;
    [ ar5++ ] = RLo
        with gr7 = RHi xor gr7;
    [ ar5 ] = gr7;
    call DAdd;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end DSUB;


//======= Макрос DMUL =======
// Умножение двух чисел типа double.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro DMUL ( ResLo, ResHi, LLo, LHi, RLo, RHi )
extern DMul :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DMul;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end DMUL;


//======= Макрос DDIV =======
// Сложение двух чисел типа double.
// На входе:    LLo - регистр с младшими 32 битами левого операнда,
//              LHi - регистр со старшими 32 битами левого операнда,
//              RLo - регистр с младшими 32 битами правого операнда,
//              RHi - регистр со старшими 32 битами правого операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro DDIV ( ResLo, ResHi, LLo, LHi, RLo, RHi )
extern DDiv :label;

    ar5 = sp;
    sp += 4;
    [ ar5++ ] = LLo;
    [ ar5++ ] = LHi;
    [ ar5++ ] = RLo;
    [ ar5 ] = RHi;
    call DDiv;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    nul;		// to correct silicon bug (3.1, 3.2).

    sp -= 4;
end DDIV;


//======= Макрос I32TOD =======
// Конвертирует 32-разрядное целое число со знаком в вещественное число
// типа double.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro I32TOD ( ResLo, ResHi, Arg )
extern ConvI32toD :label;

    CALL_BUILTIN_1x2( ConvI32toD, Arg, ResHi, ResLo );

end I32TOD;


//======= Макрос U32TOD =======
// Конвертирует 32-разрядное целое число без знака в вещественное число
// типа double.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro U32TOD ( ResLo, ResHi, Arg )
extern ConvU32toD :label;

    CALL_BUILTIN_1x2( ConvU32toD, Arg, ResHi, ResLo );

end U32TOD;


//======= Макрос I64TOD =======
// Конвертирует 64-разрядное целое число со знаком в вещественное число
// типа double.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro I64TOD ( ResLo, ResHi, ArgLo, ArgHi )
extern ConvI64toD :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvI64toD;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end I64TOD;


//======= Макрос U64TOD =======
// Конвертирует 64-разрядное целое число без знака в вещественное число
// типа double.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro U64TOD ( ResLo, ResHi, ArgLo, ArgHi )
extern ConvU64toD :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvU64toD;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end U64TOD;


//======= Макрос DTOI32 =======
// Конвертирует вещественное число типа double
// в 32-разрядное целое число со знаком.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro DTOI32 ( Res, ArgLo, ArgHi )
extern ConvDtoI32 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoI32;
    sp -= 2
        with Res = gr7;
end DTOI32;


//======= Макрос DTOU32 =======
// Конвертирует вещественное число типа double
// в 32-разрядное целое число без знака.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro DTOU32 ( Res, ArgLo, ArgHi )
extern ConvDtoU32 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoU32;
    sp -= 2
        with Res = gr7;
end DTOU32;


//======= Макрос DTOI64 =======
// Конвертирует вещественное число типа double
// в 64-разрядное целое число со знаком.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro DTOI64 ( ResLo, ResHi, ArgLo, ArgHi )
extern ConvDtoI64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoI64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end DTOI64;


//======= Макрос DTOU64 =======
// Конвертирует вещественное число типа double
// в 64-разрядное целое число без знака.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
macro DTOU64 ( ResLo, ResHi, ArgLo, ArgHi )
extern ConvDtoU64 :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoU64;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end DTOU64;


//======= Макрос FTOD =======
// Конвертирует число типа float в число типа double.
// На входе:    Arg - регистр с операндом,
//              стек выровнен по четному адресу.
// На выходе:   ResLo - младшие 32 бита результата,
//              ResHi - старшие 32 бита результата.
// Изменяет:    gr7, ar5.
macro FTOD ( ResLo, ResHi, Arg )
extern ConvFtoD :label;

    ar5 = sp;
    sp += 2;
    [ ar5 += 1 ] = Arg;
    call ConvFtoD;
    ar5 = sp;
    ResHi = [ --ar5 ];
    ResLo = [ --ar5 ];
    sp -= 2;
end FTOD;


//======== Макрос DTOF =======
// Конвертирует число типа double в число типа float.
// На входе:    ArgLo - младшие 32 бита операнда,
//              ArgHi - старшие 32 бита операнда,
//              стек выровнен по четному адресу.
// На выходе:   Res - регистр с результатом.
// Изменяет:    gr7, ar5
macro DTOF ( Res, ArgLo, ArgHi )
extern ConvDtoF :label;

    ar5 = sp;
    sp += 2;
    [ ar5++ ] = ArgLo;
    [ ar5 ] = ArgHi;
    call ConvDtoF;
    sp -= 2
        with Res = gr7;
end DTOF;


macro FPIEEE_FLAGS_DEF ()

    const _FPIEEE_Invalid   =  1;
    const _FPIEEE_DivByZero =  2;
    const _FPIEEE_Overflow  =  4;
    const _FPIEEE_Underflow =  8;
    const _FPIEEE_Inexact   = 16;

end FPIEEE_FLAGS_DEF;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//                      Конец файла rtmacro.asm                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
