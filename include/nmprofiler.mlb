//***************************************************************************/
//*                     RC Module Inc., Moscow, Russia                      */
//*                     NeuroMatrix(r) Software                             */
//*                                                                         */
//*   Profiler library                                                      */
//*                                                                         */
//*                                                                         */
//*   Software design:  S.Mushkaev                                          */
//*                                                                         */
//*   Version           1.0                                                 */
//*   Start date:       15.04.2015                                          */
//*                                                                         */
//*                                                                         */
//***************************************************************************/




//=======================================================================================================================

// Конструктор. Макрос инициализации профилирования . Должен идти первым. 
// MAXFUNCLEN - кол-во символов до которого будет урезаться имя функции при записи в таблицу профилирования
// sizeof = 16
macro PROFILE_FUNC_BASE_DUMMY()
	  <dummy_profile_start>
	  PROFILE_FUNC_BASE(extern,__main,"__main",6,0,TRACING,0);
	  <dummy_profile_end>
end PROFILE_FUNC_BASE_DUMMY;	  
	  
	  
macro PROFILE_BEGIN(MAXFUNCLEN,USE_TRACING)
const TRACING=USE_TRACING;
const MAX_FUNCNAME_LEN=MAXFUNCLEN;
//begin ".text_nmprofiler"
	
	global profileList:label;
	global _nmprofiler_init			:label;
	global _halProfilerEnable		:label;
	extern _clock					:label; 
	extern  inject_goto				:label;
	extern	profiler_check_jump_cop4:label; // функция проверяет наличия перехода в первых 4 командах (для таких функций профилирование невозможно)
	extern _nmprofiler_enabled		:word;
	extern _nmprofiler_infosize		:word;
	extern _nmprofiler_head_addr	:word;
	extern _nmprofiler_tail_addr	:word;
	extern _nmprofiler_namesize		:word;
	extern _nmprofiler_delay		:word;
	extern _nmprofiler_size_current	:word;
	extern _nmprofiler_trace		:label;
	extern _nmprofiler_depth		:word;
	extern _nmprofiler_gr7			:word;
	
	own    next_init:label;
	//global _nmprofiler_enable:	label;
	//global _nmprofiler_disable: 	label;
	//global _nmprofiler_last : 	label;

	//[_nmprofiler_head]=gr7; // never used , only to force address assignment for  _nmprofiler_first if map-file
	//[_nmprofiler_check]=gr7;
	
	<_halProfilerEnable>
	<_nmprofiler_init>
	push ar0,gr0;
	push ar1,gr1;
	ar0 = next_init+12 with	gr7 = false;	// gr7 =0
	gr0 = MAXFUNCLEN+5;
	[_nmprofiler_infosize] =gr0;
	[_nmprofiler_head_addr]=ar0;
	PROFILE_FUNC_BASE_DUMMY(); // пустышка для измерения длины макроса
	<next_init>
	<profileList>

end  PROFILE_BEGIN;

// Деструктор
macro PROFILE_END() 			// On enter: gr7=profiler

	[_nmprofiler_tail_addr]=gr7 with gr7;
	if =0 goto reset_head_addr;	// если нет ни одной функции обнуляем _nmprofiler_head_addr
	gr0=false;			// gr0=0;
	[gr7]=gr0;			// [_timer_next]=0;
	pop ar1,gr1;
	pop ar0,gr0;
	return ;

	<reset_head_addr>
	pop ar1,gr1;
	pop ar0,gr0;
	delayed return;
		nul;
		[_nmprofiler_head_addr]=gr7;
	goto profileList;
			
//end ".text_nmprofiler";
	
end PROFILE_END;		
	

// disp =12	
macro PROFILE_FUNC_BASE(ext, funcname, funcinfo, disp, limit_depth, tracing, len_text)
//.branch;
	ext funcname				:label; // указатель на профилируемую функцию
	own timer_return			:label;
	own timer_enter				:label;
	own timer_replaced			:label;
	own timer_skip_enter		:label;
	own timer_skip_return 		:label;
	own next_init				:label;	
	own initcode				:label;
	own initcode2				:label;
	own profiler_data			:label;
	

	//=============== инициализатор,  здесь осуществляем подмену кода =============================================
	// sizeof =12
		
	<initcode>							// должен быть длинной 12 слов
	ar0 = funcname;						// адрес данных профилируемой функции
	gr1 = timer_enter;					// вставляем goto на timer_enter в начала прфилируемой функции
	delayed call inject_goto;
		gr0 = timer_replaced;			// адрес куда сохраняем замещаемый код
	


	delayed goto next_init;				// идем в конец текущего макроса PROFILE_FUNC - на начало следуещего макроса PROFILE_FUNC
		gr7 = profiler_data;			// запоминаем последний tail для деструктора PROFILE_END
	
	//---------------------------- структура данных для профилирования функции -----------------------------------
	// sizeof = 10+MAX_FUNCNAME_LEN
	<profiler_data>
		//own _timer_next	: word=next_init+12;		// указатель на следующую структуру данных profile_data в списке 
		//own _timer_next		: word=12+26+34+14+10+MAX_FUNCNAME_LEN;	 // смещение до следующей структуры и 0 если конец
		//own _timer_next		: word=0BABADEDAh;	 		// якорь для определения размера макроса
		//own _timer_funcaddr : word=len_text;			// адрес профилируемой функции
		own _timer_next		: word=len_text;	 // смещение до следующей структуры и 0 если конец
		own _timer_funcaddr : word=funcname;			// адрес профилируемой функции

		own _timer_calls	: word=0;					// кол-во вызовов
		own _timer_summary	: word=0;					// суммарное накопленное время функции
		//--------------------------------------------------------------------------------------------------------
		own _funcname		: word[MAX_FUNCNAME_LEN]=funcinfo;	// имя профилируемой функции
		own _funcname_end	: word=0;					// символ завершения строки (для обрезанных имен)
		//--------------------------------------------------------------------------------------------------------------
		own _timer_stopwatch: word=0;					// текущее время в момент вызова проф. функции 
		own _timer_ret_pswr	: long;						// тут сохраняем контекст возврата
		own _size_summary	: word=0;					// тут сохраняем суммарное количество данных
		own _dummy			: word=0;					// reserved
	
	//=============== замерщик (пуск) ===================================================
	// sizeof =26
	<timer_enter>							// сюда мы переходим по goto из профилируемой функции
	
		// сохраняем контекст возврата и подменяем точку возврата на timer_return (замерщик времени - стоп)
		push ar0,gr0;
		push ar5,gr5;	
		
	//.if limit_depth!=0;						// если есть ограничение по глубине профилирования
		gr0 = [_nmprofiler_depth];				// уровню глубины в 1 функцию соотв число -2 
		gr5 = [_nmprofiler_enabled] with gr0++;	// увеличиваем счетчик глубины профилирования
		[_nmprofiler_depth] = gr0   with gr0 A>>=31;
	//.endif; 
	//.if limit_depth==0;							// нет ограничений
	//	gr5 = [_nmprofiler_enabled] with gr0 = true; 	//  ; - любая глубина
	//.endif;
		
		ar5 = sp-disp   with gr5 = gr0 and gr5;	// ar5 - указывает на адрес возврата retaddr и pswr у профилируемой функции из которой пришли; gr5 = нужно ли профилировать
		ar0,gr0 = [ar5];						// читаем оригинальный контекст возврата
		nul;
		[_timer_ret_pswr] = ar0,gr0;			// сохраняем оригинальный контекст возврата
		ar0 = timer_return with gr5;			// устанавливаем адрес возврата на свой timer_return
		if =0 delayed goto timer_skip_enter;	// пропускаем замерщик если профилирование запрещено или функция не верхнего уровня
			[ar5] = ar0,gr0 ;					// подменяем в стеке адрес возврата из проф функции на свой timer_return (замерщик времени - стоп)
			gr0=gr7;							// сохраняем gr7 для посл восстановления
		
		ar5 = [_size_summary];									// считываем накопленный размер
		gr5 = [_nmprofiler_size_current];						// считываем текущий размер
		ar5+= gr5;
		nul;
		[_size_summary] = ar5  with gr5= false noflags;			// сохраняем новый размер
		[_nmprofiler_size_current] = gr5;						// обнуляем чтоб не портил чужие суммы
		
		
	.if tracing!=0;
		gr0 = [_nmprofiler_trace+5];  	// size-1
		gr5 = [_nmprofiler_trace+2];	// head
		ar0 = _nmprofiler_trace+16 with gr0=gr5 and gr0; // data
		ar5 = funcname with gr0<<=2;
		ar0+= gr0;
		[ar0++]= ar5 with gr0=false;	// пишем адрес функции
		[ar0++]= gr5 with gr5++;		// пишем счетчик входа (head)   ;head++
		[ar0++]= gr0 ;					// пишем вход(0) или выход(-1) 
		[_nmprofiler_trace+2] = gr5;	// обновляем head
	.endif;	
	
		delayed call _clock;				// засекаем время (пуск)
			gr0 = gr7 noflags;				// сохраняем gr7 (clock - возвращает через gr7)
			nul;
		
		[_timer_stopwatch]=gr7;				// сохраняем время в профайл функции
	.if tracing!=0;
		[ar0++]= gr7;						// сохраняем время в трасу 
	.endif;	
		
		<timer_skip_enter>
		pop ar5,gr5 with gr7=gr0 noflags;	// восстанавливаем gr7
		pop ar0,gr0;
		
		
		// выполняем исходный стартовый код профилируемой функции
		<timer_replaced>					// место для хранения 4 команд заголовка проф. функции
		nul;								// SELF-MODIFYING CODE
		nul;								// SELF-MODIFYING CODE
		delayed goto funcname+4;			// продолжаем выполнение проф. функции
			nul;							// SELF-MODIFYING CODE
			nul;							// SELF-MODIFYING CODE
			
		
	//=============== замерщик (стоп) ===================================================
	// sizeof =34+10
	<timer_return>												// сюда мы переходим после return из профилируемой функции
		push ar0,gr0;											// sp+=2 : отступаем стек, сюда мы потом подставим реальную(сохраненную) точку возврата из проф. функции
		push ar0,gr0;	
		push ar5,gr5;	
		gr0 = [_nmprofiler_depth]  ;
		gr5 = [_nmprofiler_enabled];		
		
		ar0 = gr7 	with gr7 = gr0 A>>31;						// сохраняем gr7 для восстановления после clock
		gr7 = ar0	with gr5 = gr5 and gr7;
		if =0 delayed goto timer_skip_return with gr0--;		// если не разрешено профилирование или - выход ; уменьшаем глубину
			[_nmprofiler_depth]= gr0;							// сохраняем глубину
			
	
		delayed call _clock;									// засекаем время (стоп) в gr7
			[_nmprofiler_gr7]=gr7;								// сохраняем gr7;
		
	.if tracing!=0;
		gr0 = [_nmprofiler_trace+5];  	// size-1
		gr5 = [_nmprofiler_trace+2];	// head
		ar0 = _nmprofiler_trace+16 with gr0=gr5 and gr0; // data
		ar5 = funcname with gr0<<=2;
		ar0+= gr0;
		[ar0++]= ar5 with gr0=true;		// пишем адрес функции; gr0-выход
		[ar0++]= gr5 with gr5++;		// пишем счетчик входа (head)   ;head++
		[ar0++]= gr0 ;					// пишем вход(0) или выход(-1) 
		[ar0++]= gr7 ;					// пишем время
		[_nmprofiler_trace+2] = gr5;	// обновляем head
	.endif;	
			
		gr0 = [_nmprofiler_delay];			
		gr0 = [_timer_stopwatch] with gr7+= gr0 noflags;		// считываем время вызова / коррекция gr7
		gr0 = [_timer_summary]   with gr7 = gr7 - gr0 noflags;	// считываем накопленное время | вычисляем время работы функции
		gr7 = [_timer_calls]     with gr0+= gr7 noflags;		// добавляем текущий замер времени
		[_timer_summary]=gr0     with gr7++ noflags;			// сохраняем суммарное время | увеличиваем счетчик вызовов
		[_timer_calls]=gr7		 with gr7=gr5;					// сохраняем счетчик вызовов 
		
		gr7 = [_nmprofiler_gr7];											// восстанавливаем gr7;
		<timer_skip_return>
		ar0,gr0 = [_timer_ret_pswr];							// восстанавливаем контекст возврата
		[sp-6] = ar0,gr0;
		pop ar5,gr5;
		pop ar0,gr0;
		return;
		
	<next_init>
//.wait;
end PROFILE_FUNC_BASE;

//=======================================================================================================================

// макрос профилирования функции со стандартным С-вызывом  (стандартное соглашение о передачи параметров через стек)
macro FUNCTION(funcname,funcinfo)
	  PROFILE_FUNC_BASE(extern,funcname,funcinfo,6,0,TRACING,dummy_profile_end-dummy_profile_start);
end   FUNCTION;

// макрос разрещающий профилирование только в дочерних функциях
macro PROFILE_DEPTH_FUNC(funcname,funcinfo)
	  PROFILE_FUNC_BASE(extern,funcname,funcinfo,6,1,TRACING,dummy_profile_end-dummy_profile_start);
end   PROFILE_DEPTH_FUNC;

// макрос профилирования функции с нестандартным вызовом функций  (внутреннее соглашение о передаче параметров . MUL32, DIV32...)
macro NONCFUNC(funcname,funcinfo)
	  PROFILE_FUNC_BASE(extern,funcname,funcinfo,8,0,TRACING,dummy_profile_end-dummy_profile_start);
end   NONCFUNC;


// замер стоит 94-97 тактов. 	
// кэш должен быть включен


